---
title: 设计模式-单例模式
top: false
cover: false
toc: true
mathjax: true
date: 2019-10-19 15:51:21
password:
summary: 单例模式是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
tags:
- 设计模式
categories:
- Java
---

## 设计模式之单例模式
*单例模式是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象*
>1. 单例类只能有一个实例
>2. 单例类必须自己创建自己的唯一实例
>3. 单例类对外提供一个访问该单例的全局访问点
#### 一、了解单例模式
**应用场景：** 
1. 在应用场景中，某类只要求生成一个对象的时候，如一个班班主任、班长等
2. 对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如Web中的配置对象、数据库中的连接池等
3. 当某类需要频繁的实例化，而创建的对象又频繁被销毁的时候，如多线程的连接池、网络连接池等
> ***注意事项：*** getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同时进入造成instance被多次实例化

**单例模式的结构：**
> *单例类：* 包含一个实例且能自行创建这个实例的类
> *访问类：* 使用单例的类

单例模式的结构图
![t.jpg](https://note.youdao.com/yws/res/3162/WEBRESOURCE4530fa811a5cf0f1fc7124974411f3ab)
#### 二、单例模式实现的几种方式
*单例模式通常有==两种实现形式==： **==懒汉式、饿汉式==***
1. **懒汉式，线程不安全**
> **是否Lazy初始化**：是
>
> **是否多线程安全**：否
>
> *这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronized，所以严格意义上它并不算单例模式。这种方式 **延迟加载(lazy loading)** 很明显，不要求线程安全，在多线程不能正常工作*
```
public class Singleton {
    private static Singleton instance = null;

    private  Singleton() {
    }
    /**
     * 线程安全
     * public static synchronized Singleton getInstance() {
     */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

2. **饿汉式**
> **是否Lazy初始化：** 否
>
> **是否多线程安全：** 是
>
> *这种方式比较常用，但容易产生垃圾对象*
>> 优点：没有加锁，执行效率会提高
>>
>> 缺点：类加载时就初始化，浪费内存
```
public class Singleton_Hungry {
    private static Singleton_Hungry instance = new Singleton_Hungry();
    private Singleton_Hungry() {
    }
    public static Singleton_Hungry getInstance() {
        return instance;
    }
}
```

3. **双检锁/双重校验锁（DCL，即 double-checked locking）**
> **是否Lazy初始化：** 是
>
> **是否多线程安全：** 是
>
> *这种方式采用双锁机制，安全且在多线程情况下能保持高性能*
>> 双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于singleton=new Singleton()对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用volatile修饰signleton实例变量有效，解决该问题
```
public class Singleton_DCL {
    //保证instance在所有线程同步
    private volatile static Singleton_DCL instance = null;
    //private避免类在外部被实例化
    private Singleton_DCL() {
    }
    public static Singleton_DCL getInstance() {
        if (instance == null) {
            synchronized (Singleton_DCL.class) {
                if (instance == null) {
                    instance = new Singleton_DCL();
                }
            }
        }
        return instance;
    }
}
```

4. **静态内部类单例模式**
> **是否Lazy初始化：** 是
>
> **是否多线程安全：** 是
>
> *这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用*
>> 只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，具体根据项目选择
```
public class Singleton_staticInnerClass {

    private Singleton_staticInnerClass(){
    }
    private static class Inner {
        private static final Singleton_staticInnerClass
                INSTANCE = new Singleton_staticInnerClass();
    }
    public static final Singleton_staticInnerClass getInstance() {
        return Inner.INSTANCE;
    }
}
```

5. **枚举单例模式**
> **是否Lazy初始化：** 否
>
> **是否多线程安全：** 是
>
> *这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化*
>> 这种方式是《Effective Java》中提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化
```
public enum  Singleton_enum {
    INSTANCE;
    //doSomething 该实例支持的行为

    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton_enum getInstance() {
        return Singleton_enum.INSTANCE;
    }
}
```

#### 【例子-懒汉式】

```
public class President {
    //保证instance在所有线程中同步
    private static volatile President instance = null;
    //private避免类在外部被实例化
    private President() {
        System.out.println("选举一个总统");
    }
    //在getInstance方法上加同步
    public static synchronized President getInstance() {
        if (instance == null) {
            instance = new President();
        } else {
            System.out.println("已经实例化了...");
        }
        return instance;
    }
    public void getName() {
        System.out.println("我是总统：川建国");
    }
}
```
```
public class Client {
    public static void main(String[] args) {
        President zt = President.getInstance();
        zt.getName();
        President zt_1 = President.getInstance();
        zt_1.getName();
        if (zt == zt_1) {
            System.out.println("是同一个人");
        } else {
            System.out.println("不是同一个人");
        }
    }
}
```
**运行结果**
```
选举一个总统
我是美国总统：川建国
已经实例化一次了，不能再实例化了
我是美国总统：川建国
是同一个人
```