---
title: 设计模式-工厂模式
top: false
cover: false
toc: true
mathjax: true
date: 2019-10-19 19:25:22
password:
summary: 工厂模式（Factory Pattern）是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象
tags:
- 设计模式
categories:
- Java
---

## 设计模式之工厂模式&工厂方法模式&抽象工厂模式
*工厂模式（Factory Pattern）是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象*
#### 介绍
> **定义：** 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
>
> **分类：**
>>1. *简单工厂（Simple Factory）模式*，又称静态工厂方法模式
>>2. *工厂方法（Factory Method）模式*，又称多态性工厂模式或虚拟构造子模式
>>3. *抽象工厂（Abstract Factory）模式*，又称工具箱模式
>
> **主要功能：** 主要功能是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性
>
> **在开源框架中的使用：**
>> 1. Spring中通过getBean("xxx") 获取Bean
>> 2. Java消息服务JMS中（这以消息队列ActiveMQ为例）
```
    // 1、创建一个连接工厂对象，需要指定服务的ip及端口。
    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.xx.xx:xxxxx");
    // 2、使用工厂对象创建一个Connection对象。
    Connection connection = connectionFactory.createConnection();
```
> **为什么要使用工厂模式：**
>> 1. **解耦：** 把对象的创建和使用的过程分开
>> 2. **降低代码重复：** 如果创建对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码
>> 3. **降低维护成本：** 由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建某个对象的地方去逐个修正，只需要在工厂里修改即可，降低维护成本
***
#### 一、简单工厂模式
*严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他两个工厂模式用的还是相对少得多，因为它只适应很多简单的情况*

*最重要的是它违背了我们在概述中说的 **==开放-封闭原则==**（可以通过反射的机制来避免）。因为每次你要新添加一个功能，都需要在生switch-case语句（或者if-else语句）中去修改代码，添加分支条件*

**适用场景：**
- 创建的对象较少
- 客户端不关心对象的创建过程

**简单工厂模式角色分配：**
1. **工厂(Factory)角色：** 简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以直接被外部调用，创建所需的产品对象
2. **抽象产品(Product)角色：** 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
3. **具体产品(Concrete Product)角色：** 简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例

**简单工厂模式结构图**

![s.jpg](https://note.youdao.com/yws/res/3018/WEBRESOURCE023b70852baff37122039478cf473c41)

**简单工厂实例：**

*创建一个可以绘制不同形状的绘图工具，可以绘制圆形、长方形、正方形等，每个图形都会有一个draw()方法用于绘图*
1. 创建Shape接口
```
public interface Shape {
    void draw();
}
```
2. 创建实现改接口的具体实现类
```
/**
 * 圆形
 */
public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle：圆形");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}
/**
 * 长方形
 */
public class Rectangle implements Shape {
    public Rectangle() {
        System.out.println("Rectangle：长方形");
    }
    @Override
    public void draw() {
        System.out.println("Draw Rectangle");
    }
}
/**
 * 正方形
 */
 public class Square implements Shape {
    public Square() {
        System.out.println("Square：正方形");
    }
    @Override
    public void draw() {
        System.out.println("Draw Square");
    }
}
```
3. 创建工厂类
```
public class ShapeFactory {
    //使用getShape()方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}
```
4. 测试类
```
public class Client {
    public static void main(String[] args) {
        //获取Circle的对象，并调用它的draw()方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();

        //获取Rectangle的对象，并调用它的draw()方法
        Shape rectangle = ShapeFactory.getShape("Rectangle");
        rectangle.draw();

        //获取Square的对象，并调用它的draw()方法
        Shape square = ShapeFactory.getShape("square");
        square.draw();
    }
}
```
**运行结果**
```
Circle：圆形
Draw Circle
Rectangle：长方形
Draw Rectangle
Square：正方形
Draw Square
```
*这样的实现有个问题，如果新增新的形状类型的话，就需要修改工厂类中的getShape()方法，这明显不符合 **开放-封闭原则***
#### 一-一使用反射机制改造简单工厂
**将工厂类改造为：**
```
/**
 * 利用反射解决简单工厂每次增加新的产品类型都需要修改工厂中的方法的弊端
 */
public class ShapeFactory_1 {
    //方式一：使用泛型省略类型强制转换，支持多态↑↓
    public static <T> T getClass(Class<? extends T> clazz) {
        T obj = null;
        try {
            obj = (T) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return obj;
    }
    //方式二：调用时需要进行强制转换↑↓
    public static Object getClass_1(Class<? extends Shape> clazz) {
        Object obj = null;
        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return obj;
    }
}
```
**测试类**
```
public class Client_1 {
    public static void main(String[] args) {
        Circle circle = ShapeFactory_1.getClass(Circle.class);
        circle.draw();
        Rectangle rectangle = ShapeFactory_1.getClass(Rectangle.class);
        rectangle.draw();
        //方式二：
        Square square = (Square) ShapeFactory_1.getClass_1(Square.class);
        square.draw();
    }
}
```
*使用反射的方式让程序符合了 **开放-封闭原则**，但是每一次传入的都是产品类的全部路径，还可以通过 **反射+配置文件**的方式改善*
***
#### 二、工厂方法模式
*工厂方法模式是简单工厂的进一步深化，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 **每个对象都有一个与之对应的工厂**，是工厂模式家族中用得最多的模式*

**适用场景：**
- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体的工厂类创建；客户端需要知道创建具体产品的工厂类
- 一个类通过其子类来指定创建那个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏原则
- 将创建对象的任务委托给多个多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中
>>1. 客户只知道创建产品的工厂名，而不知道具体的产品名。如TCL电视工厂、海信电视工厂等
>>2. 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口
>>3. 客户不关心创建产品的细节，只关心产品的品牌。

**工厂方法模式角色分配：**
1. ***抽象工厂(Abstract Factory)角色：*** 是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂必须实现这个接口
2. ***具体工厂(Concrete Factory)角色：*** 这是实现抽象接口的具体工厂类，包含于应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象
3. ***抽象产品(Abstract Product)角色：*** 工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口
4. ***具体产品(Concrete Product)角色：*** 这个角色实现了抽象产品角色所定义的接口。某具体产品由专门的具体工厂创建，它们之间往往一一对应

**工厂方法模式结构图**

![q.jpg](https://note.youdao.com/yws/res/2996/WEBRESOURCEfc91804b48dd0d9481ea30a44b3f09e7)

**工厂方法模式实例：**

*上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可*
1. 增加一个工厂接口
```
public interface Factory {
    Shape getShape();
}
```
2. 增加相关工厂类
```
/**
 * 圆形工厂类
 */
public class CircleFactory implements Factory {
    @Override
    public Shape getShape() {
        return new Circle();
    }
}
/**
 * 长方形工厂类
 */
 public class RectangleFactory implements Factory {
    @Override
    public Shape getShape() {
        return new Rectangle();
    }
}
/**
 * 正方形工厂类
 */
 public class SquareFactory implements Factory {
    @Override
    public Shape getShape() {
        return new Square();
    }
}
```
3. 测试类
```
public class Client {
    public static void main(String[] args) {
        CircleFactory circleFactory = new CircleFactory();
        Shape circle = circleFactory.getShape();
        circle.draw();
    }
}
```
**输出结果**
```
Circle：圆形
Draw Circle
```
#### 三、抽象工厂模式
*在工厂方法模式中，我们发现我们生产的都是同一类产品。抽象工厂模式就是工厂方法模式的进一步深化，在这个模式中的工厂类不单单创建一种产品，而是可以创建一组产品*

*是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构*

**适用场景：**
>- 和工厂方法一样客户端不需要知道它所创建的对象的类
>- 需要一组对象共同完成某种功能时，并且存在可能多组对象完成不同功能的情况(属于同一个产品族的产品)
>>1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等
>>2. 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋
>>3. 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构
>- 系统结构稳定，不会频繁的增加对象(当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改)

**抽象工厂方法模式角色分配：**
1. ***抽象工厂(Abstract Factory)角色：*** 是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口
2. ***具体工厂类(Concrete Factory)角色：*** 这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象
3. ***抽象产品(Abstract Product)角色：*** 工厂方法模式所创建对象的超类型，也就是产品对象的共同父类或共同拥有接口
4. ***具体产品(Concrete Product)角色：*** 抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于上面的工厂模式中的工厂只创建单一产品

**抽象工厂模式结构图**

![r.jpg](https://note.youdao.com/yws/res/3006/WEBRESOURCE08db0fe6b1e9b154b24ccb1046f6d307)

**抽象工厂的工厂和工厂方法中的工厂区别：**

***==抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂==***


**抽象工厂模式实例：**

*假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。（AK工厂生产AK系列产品包括子弹啊，AK枪的类型啊这些，M4A1工厂同理）*
1. 创建相关接口
```
//创建枪及子弹的接口
public interface Gun {
    void shooting();
}
public interface Bullet {
    void load();
}
```
2. 创建接口对应的实现类
```
//枪实现类
public class AK implements Gun {
    @Override
    public void shooting() {
        System.out.println("shooting with AK");
    }
}
public class M4A1 implements Gun {
    @Override
    public void shooting() {
        System.out.println("shooting with M4A1");
    }
}
//子弹实现类
public class AK_Bullet implements Bullet {
    @Override
    public void load() {
        System.out.println("load bullets with AK");
    }
}
public class M4A1_Bullet implements Bullet {
    @Override
    public void load() {
        System.out.println("load bullets with M4A1");
    }
}
```
3. 创建工厂接口
```
public interface Factory {
    Gun productGun();
    Bullet productBullet();
}
```
4.创建具体工厂
```
//AK工厂
public class AK_Factory implements Factory {
    @Override
    public Gun productGun() {
        return new AK();
    }

    @Override
    public Bullet productBullet() {
        return new AK_Bullet();
    }
}
//M4A1工厂
public class M4A1_Factory implements Factory {
    @Override
    public Gun productGun() {
        return new M4A1();
    }

    @Override
    public Bullet productBullet() {
        return new M4A1_Bullet();
    }
}
```
5. 测试类
```
public class Client {
    public static void main(String[] args) {
        Factory factory;
        Gun gun;
        Bullet bullet;
        factory = new AK_Factory();
        bullet = factory.productBullet();
        bullet.load();
        gun = factory.productGun();
        gun.shooting();
    }
}
```
**输出结果**
```
load bullets with AK
shooting with AK
```









